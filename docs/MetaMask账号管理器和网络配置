// MetaMask è´¦æˆ·ç®¡ç†å™¨
class MetaMaskAccountManager {
  constructor() {
    this.accounts = [];
    this.currentAccount = null;
    this.isConnected = false;
    this.init();
  }

  // åˆå§‹åŒ–
  async init() {
    try {
      this.checkMetaMask();
      this.setupEventListeners();
      
      // æ£€æŸ¥æ˜¯å¦å·²ç»è¿æ¥
      await this.checkConnection();
    } catch (error) {
      console.error('MetaMask åˆå§‹åŒ–å¤±è´¥:', error);
    }
  }

  // æ£€æŸ¥ MetaMask æ˜¯å¦å®‰è£…
  checkMetaMask() {
    if (typeof window.ethereum === 'undefined') {
      throw new Error('MetaMask æœªå®‰è£…ï¼Œè¯·å…ˆå®‰è£… MetaMask é’±åŒ…');
    }
    return true;
  }

  // æ£€æŸ¥å½“å‰è¿æ¥çŠ¶æ€
  async checkConnection() {
    try {
      const accounts = await window.ethereum.request({
        method: 'eth_accounts',
      });
      
      if (accounts.length > 0) {
        this.accounts = accounts;
        this.currentAccount = accounts[0];
        this.isConnected = true;
        console.log('âœ… å·²è¿æ¥è´¦æˆ·:', this.currentAccount);
        console.log('ğŸ“‹ æ‰€æœ‰è´¦æˆ·:', this.accounts);
      } else {
        this.isConnected = false;
        console.log('âŒ æœªè¿æ¥ä»»ä½•è´¦æˆ·');
      }
      
      return this.isConnected;
    } catch (error) {
      console.error('æ£€æŸ¥è¿æ¥çŠ¶æ€å¤±è´¥:', error);
      return false;
    }
  }

  // è¿æ¥ MetaMaskï¼ˆè¯·æ±‚è´¦æˆ·æˆæƒï¼‰
  async connect() {
    try {
      this.checkMetaMask();
      
      console.log('ğŸ”— æ­£åœ¨è¯·æ±‚è¿æ¥ MetaMask...');
      const accounts = await window.ethereum.request({
        method: 'eth_requestAccounts',
      });

      if (accounts.length === 0) {
        throw new Error('ç”¨æˆ·æ‹’ç»äº†è¿æ¥è¯·æ±‚');
      }

      this.accounts = accounts;
      this.currentAccount = accounts[0];
      this.isConnected = true;

      console.log('âœ… MetaMask è¿æ¥æˆåŠŸ!');
      console.log('ğŸ‘¤ å½“å‰è´¦æˆ·:', this.currentAccount);
      console.log('ğŸ“‹ æ‰€æœ‰è´¦æˆ·:', this.accounts);

      return {
        success: true,
        currentAccount: this.currentAccount,
        allAccounts: this.accounts,
      };
    } catch (error) {
      console.error('âŒ MetaMask è¿æ¥å¤±è´¥:', error);
      this.isConnected = false;
      throw error;
    }
  }

  // æ–­å¼€è¿æ¥
  async disconnect() {
    try {
      // MetaMask æ²¡æœ‰ç›´æ¥çš„æ–­å¼€æ–¹æ³•ï¼Œä½†æˆ‘ä»¬å¯ä»¥æ¸…é™¤æœ¬åœ°çŠ¶æ€
      this.accounts = [];
      this.currentAccount = null;
      this.isConnected = false;
      
      console.log('ğŸ“¤ å·²æ–­å¼€ MetaMask è¿æ¥');
      return true;
    } catch (error) {
      console.error('æ–­å¼€è¿æ¥å¤±è´¥:', error);
      throw error;
    }
  }

  // è·å–æ‰€æœ‰è´¦æˆ·
  async getAllAccounts() {
    try {
      const accounts = await window.ethereum.request({
        method: 'eth_accounts',
      });
      this.accounts = accounts;
      console.log('ğŸ“‹ è·å–åˆ°æ‰€æœ‰è´¦æˆ·:', accounts);
      return accounts;
    } catch (error) {
      console.error('è·å–è´¦æˆ·åˆ—è¡¨å¤±è´¥:', error);
      throw error;
    }
  }

  // åˆ‡æ¢åˆ°æŒ‡å®šè´¦æˆ·ï¼ˆé€šè¿‡ç´¢å¼•ï¼‰
  async switchToAccount(accountIndex) {
    try {
      await this.getAllAccounts();
      
      if (accountIndex < 0 || accountIndex >= this.accounts.length) {
        throw new Error(`æ— æ•ˆçš„è´¦æˆ·ç´¢å¼•: ${accountIndex}`);
      }

      const targetAccount = this.accounts[accountIndex];
      
      // è¯·æ±‚åˆ‡æ¢åˆ°æŒ‡å®šè´¦æˆ·
      await window.ethereum.request({
        method: 'wallet_requestPermissions',
        params: [{ eth_accounts: {} }],
      });

      // æ›´æ–°å½“å‰è´¦æˆ·
      this.currentAccount = targetAccount;
      console.log(`âœ… å·²åˆ‡æ¢åˆ°è´¦æˆ·: ${targetAccount}`);
      
      return {
        success: true,
        account: targetAccount,
        index: accountIndex,
      };
    } catch (error) {
      console.error('åˆ‡æ¢è´¦æˆ·å¤±è´¥:', error);
      throw error;
    }
  }

  // åˆ‡æ¢åˆ°æŒ‡å®šè´¦æˆ·ï¼ˆé€šè¿‡åœ°å€ï¼‰
  async switchToAccountByAddress(address) {
    try {
      await this.getAllAccounts();
      
      const accountIndex = this.accounts.findIndex(
        account => account.toLowerCase() === address.toLowerCase()
      );
      
      if (accountIndex === -1) {
        throw new Error(`è´¦æˆ·åœ°å€ä¸å­˜åœ¨: ${address}`);
      }

      return await this.switchToAccount(accountIndex);
    } catch (error) {
      console.error('æŒ‰åœ°å€åˆ‡æ¢è´¦æˆ·å¤±è´¥:', error);
      throw error;
    }
  }

  // è·å–è´¦æˆ·ä½™é¢
  async getAccountBalance(account = this.currentAccount) {
    try {
      if (!account) {
        throw new Error('æœªæŒ‡å®šè´¦æˆ·åœ°å€');
      }

      const balance = await window.ethereum.request({
        method: 'eth_getBalance',
        params: [account, 'latest'],
      });

      // å°† Wei è½¬æ¢ä¸º ETH
      const balanceInEth = parseInt(balance, 16) / Math.pow(10, 18);
      
      console.log(`ğŸ’° è´¦æˆ· ${account} ä½™é¢: ${balanceInEth.toFixed(4)} ETH`);
      return {
        wei: balance,
        eth: balanceInEth,
        formatted: `${balanceInEth.toFixed(4)} ETH`,
      };
    } catch (error) {
      console.error('è·å–ä½™é¢å¤±è´¥:', error);
      throw error;
    }
  }

  // è·å–æ‰€æœ‰è´¦æˆ·çš„ä½™é¢
  async getAllAccountsWithBalance() {
    try {
      await this.getAllAccounts();
      
      const accountsWithBalance = await Promise.all(
        this.accounts.map(async (account, index) => {
          try {
            const balance = await this.getAccountBalance(account);
            return {
              index,
              address: account,
              balance: balance,
              isCurrent: account === this.currentAccount,
            };
          } catch (error) {
            return {
              index,
              address: account,
              balance: { eth: 0, formatted: '0 ETH' },
              isCurrent: account === this.currentAccount,
              error: error.message,
            };
          }
        })
      );

      console.log('ğŸ’¼ æ‰€æœ‰è´¦æˆ·ä¿¡æ¯:', accountsWithBalance);
      return accountsWithBalance;
    } catch (error) {
      console.error('è·å–è´¦æˆ·ä½™é¢å¤±è´¥:', error);
      throw error;
    }
  }

  // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
  setupEventListeners() {
    if (!window.ethereum) return;

    // ç›‘å¬è´¦æˆ·å˜åŒ–
    window.ethereum.on('accountsChanged', async (accounts) => {
      console.log('ğŸ‘¤ è´¦æˆ·å‘ç”Ÿå˜åŒ–:', accounts);
      
      if (accounts.length === 0) {
        // ç”¨æˆ·æ–­å¼€äº†è¿æ¥
        this.accounts = [];
        this.currentAccount = null;
        this.isConnected = false;
        console.log('ğŸ“¤ ç”¨æˆ·å·²æ–­å¼€æ‰€æœ‰è´¦æˆ·');
        this.onAccountDisconnected();
      } else {
        // ç”¨æˆ·åˆ‡æ¢äº†è´¦æˆ·
        this.accounts = accounts;
        this.currentAccount = accounts[0];
        this.isConnected = true;
        console.log('ğŸ”„ è´¦æˆ·å·²åˆ‡æ¢åˆ°:', this.currentAccount);
        this.onAccountChanged(this.currentAccount);
      }
    });

    // ç›‘å¬ç½‘ç»œå˜åŒ–
    window.ethereum.on('chainChanged', (chainId) => {
      console.log('ğŸ”— ç½‘ç»œå·²å˜åŒ–:', chainId);
      this.onNetworkChanged(chainId);
    });
  }

  // è´¦æˆ·å˜åŒ–å›è°ƒï¼ˆå¯é‡å†™ï¼‰
  onAccountChanged(newAccount) {
    console.log('ğŸ”„ è§¦å‘è´¦æˆ·å˜åŒ–äº‹ä»¶:', newAccount);
    // åœ¨è¿™é‡Œæ·»åŠ æ‚¨çš„è‡ªå®šä¹‰é€»è¾‘
  }

  // è´¦æˆ·æ–­å¼€å›è°ƒï¼ˆå¯é‡å†™ï¼‰
  onAccountDisconnected() {
    console.log('ğŸ“¤ è§¦å‘è´¦æˆ·æ–­å¼€äº‹ä»¶');
    // åœ¨è¿™é‡Œæ·»åŠ æ‚¨çš„è‡ªå®šä¹‰é€»è¾‘
  }

  // ç½‘ç»œå˜åŒ–å›è°ƒï¼ˆå¯é‡å†™ï¼‰
  onNetworkChanged(chainId) {
    console.log('ğŸ”— è§¦å‘ç½‘ç»œå˜åŒ–äº‹ä»¶:', chainId);
    // åœ¨è¿™é‡Œæ·»åŠ æ‚¨çš„è‡ªå®šä¹‰é€»è¾‘
  }

  // è·å–å½“å‰çŠ¶æ€
  getStatus() {
    return {
      isConnected: this.isConnected,
      currentAccount: this.currentAccount,
      allAccounts: this.accounts,
      accountCount: this.accounts.length,
    };
  }
}

// å¿«æ·å‡½æ•°
async function quickConnect() {
  const manager = new MetaMaskAccountManager();
  return await manager.connect();
}

async function quickSwitchAccount(accountIndex) {
  const manager = new MetaMaskAccountManager();
  return await manager.switchToAccount(accountIndex);
}

async function quickGetAllAccounts() {
  const manager = new MetaMaskAccountManager();
  return await manager.getAllAccountsWithBalance();
}

// å¯¼å‡º
export {
  MetaMaskAccountManager,
  quickConnect,
  quickSwitchAccount,
  quickGetAllAccounts,
};

// ä½¿ç”¨ç¤ºä¾‹
/*
// 1. åŸºæœ¬ä½¿ç”¨
const accountManager = new MetaMaskAccountManager();
await accountManager.connect();                    // è¿æ¥
await accountManager.switchToAccount(1);           // åˆ‡æ¢åˆ°ç¬¬2ä¸ªè´¦æˆ·
await accountManager.getAllAccountsWithBalance();  // è·å–æ‰€æœ‰è´¦æˆ·å’Œä½™é¢

// 2. å¿«æ·æ–¹å¼
await quickConnect();                              // å¿«é€Ÿè¿æ¥
await quickSwitchAccount(0);                       // åˆ‡æ¢åˆ°ç¬¬1ä¸ªè´¦æˆ·
const accounts = await quickGetAllAccounts();      // è·å–è´¦æˆ·åˆ—è¡¨

// 3. HTML é›†æˆç¤ºä¾‹
<button onclick="quickConnect()">è¿æ¥ MetaMask</button>
<button onclick="quickSwitchAccount(0)">åˆ‡æ¢åˆ°è´¦æˆ· 1</button>
<button onclick="quickSwitchAccount(1)">åˆ‡æ¢åˆ°è´¦æˆ· 2</button>
<button onclick="quickGetAllAccounts().then(console.log)">æ˜¾ç¤ºæ‰€æœ‰è´¦æˆ·</button>

// 4. è‡ªå®šä¹‰äº‹ä»¶å¤„ç†
class MyApp extends MetaMaskAccountManager {
  onAccountChanged(newAccount) {
    document.getElementById('current-account').textContent = newAccount;
    this.updateUI();
  }
  
  onAccountDisconnected() {
    document.getElementById('current-account').textContent = 'æœªè¿æ¥';
    this.showLoginButton();
  }
}
*/

// MetaMask ç½‘ç»œé…ç½®
const NETWORK_CONFIGS = {
  ethereum: {
    chainId: '0x1',
    chainName: 'Ethereum Mainnet',
    nativeCurrency: {
      name: 'Ether',
      symbol: 'ETH',
      decimals: 18,
    },
    rpcUrls: ['https://mainnet.infura.io/v3/YOUR_INFURA_KEY'],
    blockExplorerUrls: ['https://etherscan.io/'],
  },
  polygon: {
    chainId: '0x89',
    chainName: 'Polygon Mainnet',
    nativeCurrency: {
      name: 'MATIC',
      symbol: 'MATIC',
      decimals: 18,
    },
    rpcUrls: ['https://polygon-rpc.com/'],
    blockExplorerUrls: ['https://polygonscan.com/'],
  },
  bsc: {
    chainId: '0x38',
    chainName: 'BNB Smart Chain',
    nativeCurrency: {
      name: 'BNB',
      symbol: 'BNB',
      decimals: 18,
    },
    rpcUrls: ['https://bsc-dataseed1.binance.org/'],
    blockExplorerUrls: ['https://bscscan.com/'],
  },
  arbitrum: {
    chainId: '0xa4b1',
    chainName: 'Arbitrum One',
    nativeCurrency: {
      name: 'Ether',
      symbol: 'ETH',
      decimals: 18,
    },
    rpcUrls: ['https://arb1.arbitrum.io/rpc'],
    blockExplorerUrls: ['https://arbiscan.io/'],
  },
  optimism: {
    chainId: '0xa',
    chainName: 'Optimism',
    nativeCurrency: {
      name: 'Ether',
      symbol: 'ETH',
      decimals: 18,
    },
    rpcUrls: ['https://mainnet.optimism.io/'],
    blockExplorerUrls: ['https://optimistic.etherscan.io/'],
  },
  base: {
    chainId: '0x2105',
    chainName: 'Base',
    nativeCurrency: {
      name: 'Ether',
      symbol: 'ETH',
      decimals: 18,
    },
    rpcUrls: ['https://mainnet.base.org/'],
    blockExplorerUrls: ['https://basescan.org/'],
  },
  avalanche: {
    chainId: '0xa86a',
    chainName: 'Avalanche C-Chain',
    nativeCurrency: {
      name: 'AVAX',
      symbol: 'AVAX',
      decimals: 18,
    },
    rpcUrls: ['https://api.avax.network/ext/bc/C/rpc'],
    blockExplorerUrls: ['https://snowtrace.io/'],
  },
  // æµ‹è¯•ç½‘ç»œ
  sepolia: {
    chainId: '0xaa36a7',
    chainName: 'Sepolia Testnet',
    nativeCurrency: {
      name: 'Sepolia Ether',
      symbol: 'SEP',
      decimals: 18,
    },
    rpcUrls: ['https://sepolia.infura.io/v3/YOUR_INFURA_KEY'],
    blockExplorerUrls: ['https://sepolia.etherscan.io/'],
  },
  polygonMumbai: {
    chainId: '0x13881',
    chainName: 'Polygon Mumbai Testnet',
    nativeCurrency: {
      name: 'MATIC',
      symbol: 'MATIC',
      decimals: 18,
    },
    rpcUrls: ['https://rpc-mumbai.maticvigil.com/'],
    blockExplorerUrls: ['https://mumbai.polygonscan.com/'],
  },
};

// æ£€æŸ¥æ˜¯å¦å®‰è£…äº† MetaMask
function checkMetaMask() {
  if (typeof window.ethereum === 'undefined') {
    throw new Error('MetaMask æœªå®‰è£…ï¼Œè¯·å…ˆå®‰è£… MetaMask é’±åŒ…');
  }
  return true;
}

// è¿æ¥ MetaMask
async function connectMetaMask() {
  try {
    checkMetaMask();
    const accounts = await window.ethereum.request({
      method: 'eth_requestAccounts',
    });
    console.log('âœ… MetaMask è¿æ¥æˆåŠŸ:', accounts[0]);
    return accounts[0];
  } catch (error) {
    console.error('âŒ MetaMask è¿æ¥å¤±è´¥:', error);
    throw error;
  }
}

// è·å–å½“å‰ç½‘ç»œä¿¡æ¯
async function getCurrentNetwork() {
  try {
    checkMetaMask();
    const chainId = await window.ethereum.request({
      method: 'eth_chainId',
    });
    console.log('ğŸ”— å½“å‰ç½‘ç»œ Chain ID:', chainId);
    return chainId;
  } catch (error) {
    console.error('âŒ è·å–ç½‘ç»œä¿¡æ¯å¤±è´¥:', error);
    throw error;
  }
}

// åˆ‡æ¢åˆ°æŒ‡å®šç½‘ç»œ
async function switchToNetwork(networkName) {
  try {
    checkMetaMask();
    
    const networkConfig = NETWORK_CONFIGS[networkName];
    if (!networkConfig) {
      throw new Error(`ä¸æ”¯æŒçš„ç½‘ç»œ: ${networkName}`);
    }

    console.log(`ğŸ”„ æ­£åœ¨åˆ‡æ¢åˆ° ${networkConfig.chainName}...`);

    try {
      // å°è¯•åˆ‡æ¢åˆ°ç›®æ ‡ç½‘ç»œ
      await window.ethereum.request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId: networkConfig.chainId }],
      });
      console.log(`âœ… æˆåŠŸåˆ‡æ¢åˆ° ${networkConfig.chainName}`);
      return true;
    } catch (switchError) {
      // å¦‚æœç½‘ç»œä¸å­˜åœ¨ï¼Œå°è¯•æ·»åŠ ç½‘ç»œ
      if (switchError.code === 4902) {
        console.log(`ğŸ“ ç½‘ç»œä¸å­˜åœ¨ï¼Œæ­£åœ¨æ·»åŠ  ${networkConfig.chainName}...`);
        await addNetwork(networkConfig);
        return true;
      } else {
        throw switchError;
      }
    }
  } catch (error) {
    console.error(`âŒ åˆ‡æ¢ç½‘ç»œå¤±è´¥:`, error);
    throw error;
  }
}

// æ·»åŠ æ–°ç½‘ç»œåˆ° MetaMask
async function addNetwork(networkConfig) {
  try {
    await window.ethereum.request({
      method: 'wallet_addEthereumChain',
      params: [networkConfig],
    });
    console.log(`âœ… æˆåŠŸæ·»åŠ ç½‘ç»œ: ${networkConfig.chainName}`);
  } catch (error) {
    console.error(`âŒ æ·»åŠ ç½‘ç»œå¤±è´¥:`, error);
    throw error;
  }
}

// æ‰¹é‡åˆ‡æ¢ç½‘ç»œï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
async function switchWithRetry(networkName, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      await switchToNetwork(networkName);
      return true;
    } catch (error) {
      console.log(`é‡è¯• ${i + 1}/${maxRetries}: ${error.message}`);
      if (i === maxRetries - 1) {
        throw error;
      }
      // ç­‰å¾… 1 ç§’åé‡è¯•
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
}

// ç›‘å¬ç½‘ç»œåˆ‡æ¢äº‹ä»¶
function setupNetworkListener() {
  if (window.ethereum) {
    window.ethereum.on('chainChanged', (chainId) => {
      console.log('ğŸ”„ ç½‘ç»œå·²åˆ‡æ¢ï¼Œæ–°çš„ Chain ID:', chainId);
      // é¡µé¢å¯èƒ½éœ€è¦åˆ·æ–°æ¥é€‚åº”æ–°ç½‘ç»œ
      window.location.reload();
    });

    window.ethereum.on('accountsChanged', (accounts) => {
      console.log('ğŸ‘¤ è´¦æˆ·å·²åˆ‡æ¢:', accounts[0] || 'æœªè¿æ¥');
      if (accounts.length === 0) {
        console.log('ğŸ“¤ ç”¨æˆ·å·²æ–­å¼€è¿æ¥');
      }
    });
  }
}

// å·¥å…·å‡½æ•°ï¼šè·å–ç½‘ç»œåç§°
function getNetworkName(chainId) {
  const networkMap = {
    '0x1': 'Ethereum Mainnet',
    '0x89': 'Polygon',
    '0x38': 'BNB Smart Chain',
    '0xa4b1': 'Arbitrum One',
    '0xa': 'Optimism',
    '0x2105': 'Base',
    '0xa86a': 'Avalanche',
    '0xaa36a7': 'Sepolia Testnet',
    '0x13881': 'Polygon Mumbai',
  };
  return networkMap[chainId] || `Unknown Network (${chainId})`;
}

// ä½¿ç”¨ç¤ºä¾‹å’Œ UI äº¤äº’å‡½æ•°
class MetaMaskNetworkSwitcher {
  constructor() {
    this.currentAccount = null;
    this.currentChainId = null;
    this.init();
  }

  async init() {
    try {
      checkMetaMask();
      setupNetworkListener();
      
      // è·å–å½“å‰çŠ¶æ€
      this.currentChainId = await getCurrentNetwork();
      console.log('ğŸŒ å½“å‰ç½‘ç»œ:', getNetworkName(this.currentChainId));
    } catch (error) {
      console.error('åˆå§‹åŒ–å¤±è´¥:', error);
    }
  }

  async connect() {
    this.currentAccount = await connectMetaMask();
    return this.currentAccount;
  }

  async switchTo(networkName) {
    return await switchToNetwork(networkName);
  }

  async switchWithRetry(networkName, maxRetries = 3) {
    return await switchWithRetry(networkName, maxRetries);
  }

  getSupportedNetworks() {
    return Object.keys(NETWORK_CONFIGS);
  }

  getNetworkConfig(networkName) {
    return NETWORK_CONFIGS[networkName];
  }
}

// å¯¼å‡ºæ‰€æœ‰å‡½æ•°ä¾›å¤–éƒ¨ä½¿ç”¨
export {
  checkMetaMask,
  connectMetaMask,
  getCurrentNetwork,
  switchToNetwork,
  addNetwork,
  switchWithRetry,
  setupNetworkListener,
  getNetworkName,
  MetaMaskNetworkSwitcher,
  NETWORK_CONFIGS,
};

// ä½¿ç”¨ç¤ºä¾‹
/*
// åˆ›å»ºå®ä¾‹
const networkSwitcher = new MetaMaskNetworkSwitcher();

// è¿æ¥ MetaMask
await networkSwitcher.connect();

// åˆ‡æ¢åˆ°ä¸åŒç½‘ç»œ
await networkSwitcher.switchTo('polygon');      // åˆ‡æ¢åˆ° Polygon
await networkSwitcher.switchTo('bsc');          // åˆ‡æ¢åˆ° BSC
await networkSwitcher.switchTo('arbitrum');     // åˆ‡æ¢åˆ° Arbitrum
await networkSwitcher.switchTo('optimism');     // åˆ‡æ¢åˆ° Optimism

// æˆ–è€…ç›´æ¥ä½¿ç”¨å‡½æ•°
await switchToNetwork('ethereum');              // åˆ‡æ¢åˆ°ä»¥å¤ªåŠä¸»ç½‘
await switchToNetwork('sepolia');               // åˆ‡æ¢åˆ°æµ‹è¯•ç½‘

// å¸¦é‡è¯•çš„åˆ‡æ¢
await switchWithRetry('polygon', 3);            // æœ€å¤šé‡è¯• 3 æ¬¡
*/